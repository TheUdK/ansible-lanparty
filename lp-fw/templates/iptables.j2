# {{ ansible_managed }}
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]

# Input Filtering
-A INPUT -i lo -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -p tcp -m tcp --dport ssh -m set --match-set RFC1918 src -j ACCEPT
-A INPUT -p tcp -m tcp --dport {{ observium.agent.port }} -m set --match-set RFC1918 src -j ACCEPT
-A INPUT -p udp -m udp --dport snmp -m set --match-set RFC1918 src -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-port-unreachable

# Accept all packets matched to related/established connections
-A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

# Hosts exempt from block rules
{% for r in fw_exempt %}
-A FORWARD -s {{ r }} -j ACCEPT
{% endfor %}

# Source hosts to block
{% for h in fw_block.hosts %}
-A FORWARD -s {{ h }} -j REJECT
{% endfor %}

# Destination ports to block
{% for p in fw_block.ports %}
-A FORWARD -p tcp -m tcp --dport {{ p }} -m set ! --match-set RFC1918 dst -j REJECT
-A FORWARD -p udp -m udp --dport {{ p }} -m set ! --match-set RFC1918 dst -j REJECT
{% endfor %}
COMMIT

*mangle
####
# Default Chains
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]

####
# Link Selection Chains
{% for name, ch in fw_ch_ls|dictsort() %}
:{{ ch }} - [0:0]
{% endfor %}

####
# Quality of Service Chains
{% for name, ch in fw_ch_qos|dictsort() %}
:{{ ch }} - [0:0]
{% endfor %}

####
# Game Chains
{% for name, ch in fw_ch_game|dictsort() %}
:{{ ch }} - [0:0]
{% endfor %}

##  vv OVERVIEW vv  ###########################################################

########
# :: PREROUTING ::
# Execute Link Selection
####

## Determine Connection State [new/existing]
# If we need to create a new connection, send to {{ fw_ch_ls.new }} chain, where link selection decision is made
# If packet belongs to existing connection, send to {{ fw_ch_ls.open }} chain, restoring decision to packet
-A PREROUTING -m conntrack ! --ctstate NEW -j {{ fw_ch_ls.open }}
-A PREROUTING -m conntrack --ctstate NEW -j {{ fw_ch_ls.new }}

########
# :: FORWARD ::
# Execute QoS Class Selection
####

## Match against bogon IPSet (RFC1918)
# If source matches external address, send to {{ fw_ch_qos.in }}, else send to {{ fw_ch_qos.out }}
-A FORWARD -m set ! --match-set RFC1918 src -j {{ fw_ch_qos.in }}
-A FORWARD -m set --match-set RFC1918 src -j {{ fw_ch_qos.out }}

########
# :: POSTROUTING ::
# Thrash hogs, save packet mark to connection and tag with DSCP
####

## Bandwidth Hogging Detection
# [ from, to, threshold (bytes), direction ]
{% for h in fw_hog %}
-A POSTROUTING -m mark --mark {{ fw_mark.class[h.0] }}/0xf -m connbytes --connbytes {{ h.2 }} --connbytes-mode bytes --connbytes-dir {{ h.3 }} -j MARK --set-xmark {{ fw_mark.class[h.1] }}/0xf
{% endfor %}

## Save Packet Class Mark to Connection
{% for c, m in fw_mark.class|dictsort(false, 'value') %}
-A POSTROUTING -m mark --mark {{ m }}/0xf -m connmark ! --mark {{ m }}/0xf -j CONNMARK --save-mark --nfmask 0xf --ctmask 0xf
{% endfor %}

## Assign DSCP Mark
{% for c, m in fw_mark.class|dictsort(false, 'value') %}
-A POSTROUTING -m mark --mark {{ m }}/0xf -j DSCP --set-dscp {{ fw_dscp[c] }}
{% endfor %}

##  ^^ OVERVIEW ^^  ###########################################################

####
# Link Selection Chains
# Triggered in PREROUTING
####
## New Connection
# Check which direction packet came from
# Send packet through {{ fw_ch_ls.in }} or {{ fw_ch_ls.out }} accordingly
# Save the decision made in {{ fw_ch_ls.in }} or {{ fw_ch_ls.out }} to the connection
-A {{ fw_ch_ls.new }} -m comment --comment "Inbound Packets" -m set ! --match-set RFC1918 src -j {{ fw_ch_ls.in }}
-A {{ fw_ch_ls.new }} -m comment --comment "Outbound Packets" -m set --match-set RFC1918 src -j {{ fw_ch_ls.out }}
-A {{ fw_ch_ls.new }} -m comment --comment "Save Link Selection bit of packet to connection" -j CONNMARK --save-mark --nfmask 0xf0 --ctmask 0xf0

## Existing Connection
# Connection is already known, restore our decision to the packet
-A {{ fw_ch_ls.open }} -m comment --comment "Restore entire LS/QOS decision to packet" -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff

## Incoming packet
# Mark packet based on WAN link where it came in
{% for i, m in fw_mark.link|dictsort() %}
-A {{ fw_ch_ls.in }} -i {{ fw_link[i] }} -j MARK --set-xmark {{ m }}/0xf0
{% endfor %}

## Dedicated Link Selection Exceptions
# We might want to overrule the link selection algorithm
{% for d in fw_dedi %}
-A {{ fw_ch_ls.out }} -m mark --mark 0x0/0xf0 -s {{ d.0 }}{% if d.2 is defined %} -m comment --comment "{{ d.2 }}"{% endif %} -j MARK --set-xmark {{ fw_mark.link[d.1] }}/0xf0
{% endfor %}

## Outgoing Link Selection
# Select an ISP based on the packet's source IP
# Does not clobber the selection made in "Link Selection Exceptions"
{% for name, r in fw_domain|dictsort(false, 'value') %}
-A {{ fw_ch_ls.out }} -m mark --mark 0x0/0xf0 -m comment --comment "[ {{ name|center(18) }} ]" -s {{ r.0 }} -j MARK --set-xmark {{ fw_mark.link[r.1] }}/0xf0
{% endfor %}

# Default mark if no group matched
# TODO: Log this
-A {{ fw_ch_ls.out }} -m mark --mark 0x0/0xf0 -j MARK --set-xmark 0x40/0xf0

####
# Quality of Service Chains
# Triggered in FORWARD
####

## Smokeping Chain
-A {{ fw_ch_qos.out }} -s 10.16.4.121/32 -m comment --comment "SMOKEPING" -j {{ fw_ch_qos.ping }}

## Hosts Quality of Service
{% for h in fw_qos.hosts %}
-A {{ fw_ch_qos.out }} -m mark --mark 0x0/0xf -s {{ h.0 }}{% if h.2 is defined %} -m comment --comment "{{ h.2 }}"{% endif %} -j MARK --set-xmark {{ fw_mark.class[h.1] }}/0xf
{% endfor %}

## Take a journey through the games chain
-A {{ fw_ch_qos.out }} -m mark --mark 0x0/0xf -j {{ fw_ch_qos.games }}

## Misc Quality of Service Rules
{% for p in fw_qos.ports %}
{% if p.0 == 'icmp' %}
-A {{ fw_ch_qos.out }} -m mark --mark 0x0/0xf -p icmp -j MARK --set-xmark {{ fw_mark.class[p.2] }}/0xf
{% endif %}
{% if p.0 == 'both' or p.0 == 'tcp' %}
-A {{ fw_ch_qos.out }} -m mark --mark 0x0/0xf -p tcp -m tcp --dport {{ p.1 }} -j MARK --set-xmark {{ fw_mark.class[p.2] }}/0xf
{% endif %}
{% if p.0 == 'both' or p.0 == 'udp' %}
-A {{ fw_ch_qos.out }} -m mark --mark 0x0/0xf -p udp -m udp --dport {{ p.1 }} -j MARK --set-xmark {{ fw_mark.class[p.2] }}/0xf
{% endif %}
{% endfor %}

## Trash packets that have default mark after restore in {{ fw_ch_ls.open }} in PREROUTING and QoS selection
-A {{ fw_ch_qos.in }} -m mark --mark 0x0/0xf -m comment --comment "Default QOS Mark" -j MARK --set-xmark {{ fw_mark.class.trash }}/0xf
-A {{ fw_ch_qos.out }} -m mark --mark 0x0/0xf -m comment --comment "Default QOS Mark" -j MARK --set-xmark {{ fw_mark.class.trash }}/0xf

####
# Game Chains
# Triggered in FORWARD through {{ fw_ch_qos.out }}
####
## Jump to specific game chains in {{ fw_ch_qos.games }}
{% for k, g in fw_ch_game|dictsort() %}
-A {{ fw_ch_qos.games }} -j {{ g }}
{% endfor %}

## Game Chains
{% for n, g in fw_qos.games|dictsort() %}
  {%- if g.ports is defined %}
    {%- for p in g.ports %}
{% if p.0 == 'tcp' or p.0 == 'udp' %}
-A {{ fw_ch_game[n] }} -p {{ p.0 }} -m {{ p.0 }} --dport {{ p.1 }}{% if p.3 is defined %} --sport {{ p.3 }}{% endif %} -j MARK --set-xmark {{ fw_mark.class[p.2] }}/0xf
{% endif %}
{% if p.0 == 'both' %}
-A {{ fw_ch_game[n] }} -p udp -m udp --dport {{ p.1 }}{% if p.3 is defined %} --sport {{ p.3 }}{% endif %} -j MARK --set-xmark {{ fw_mark.class[p.2] }}/0xf
-A {{ fw_ch_game[n] }} -p tcp -m tcp --dport {{ p.1 }}{% if p.3 is defined %} --sport {{ p.3 }}{% endif %} -j MARK --set-xmark {{ fw_mark.class[p.2] }}/0xf
{% endif %}
    {%- endfor %}
  {%- endif %}
  {%- if g.sets is defined %}
    {%- for p in g.sets %}
{% if p.0 == 'tcp' or p.0 == 'udp' %}
-A {{ fw_ch_game[n] }} -p {{ p.0 }} -m {{ p.0 }} -m set --match-set {{ p.1 }} {{ p.2 }} --dport {{ p.3 }}{% if p.5 is defined %} --sport {{ p.5 }}{% endif %} -j MARK --set-xmark {{ fw_mark.class[p.4] }}/0xf
{% endif %}
{% if p.0 == 'both' %}
-A {{ fw_ch_game[n] }} -p udp -m tcp -m set --match-set {{ p.1 }} {{ p.2 }} --dport {{ p.3 }}{% if p.5 is defined %} --sport {{ p.5 }}{% endif %} -j MARK --set-xmark {{ fw_mark.class[p.4] }}/0xf
-A {{ fw_ch_game[n] }} -p udp -m tcp -m set --match-set {{ p.1 }} {{ p.2 }} --dport {{ p.3 }}{% if p.5 is defined %} --sport {{ p.5 }}{% endif %} -j MARK --set-xmark {{ fw_mark.class[p.4] }}/0xf
{% endif %}
    {%- endfor %}
  {%- endif %}
{%- endfor %}

## Smokeping Probes
{% for n, p in ping_providers|dictsort() %}
{% for cn, c in p.classes|dictsort() %}
-A {{ fw_ch_qos.ping }} -m dscp --dscp {{ c.0 }} -j MARK --set-xmark {{ c.1 }}/0xffffffff
{% endfor %}
{% endfor %}

COMMIT

*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]

# Routes to SNAT
{% for s, d in fw_snat %}
-A POSTROUTING -s {{ s }} -d {{ d }} -j MASQUERADE
{% endfor %}
COMMIT
